#需求
网盘，用户登录之后可以像本地磁盘一样管理自己的文件夹和文件。

该系统需要可以水平扩展，可以使用成本低廉的服务器集群，当应用请求较多、或磁盘空间不足时，可以启用新的节点；

当其中一个节点故障（网络中断、节点关闭、节点崩溃……）不会对系统产生影响。

系统可以动态调整用户配额，用户可以分享自己的文件。

## 系统分析与设计
根据需求可以看出，这套系统需要有用户权限管理，分布式文件索引，开放的应用接口和分布式文件存储。

用户权限管理
使用自定义的Json Web Token.由其它系统提交。文件系统只负责验证Token的有效性和用户角色。

文件索引（Metadata Store）
文件索引是文件名（包含路径）到 File ID 的映射，是一个典型的 Key-Value 数据库。它至少需要支持以下方法：
Put 新增或更新一个Key对应的Value
Delete 删除一个Key以及对应的Value
除此以外，文件的Metadata还需要包含修改日期、大小等，方便List时快速获取到这些信息。 文件索引是系统中的最重要的部分，如果索引丢失，用户无法从API或UI上查询到任何关于File ID的信息，即使此时文件仍然存在，也会和消失没有什么区别。
技术上使用Redis Sentinel作为高可用文件索引的方案。
Sentinel 只提供了 Master 选举和切换功能，我们还需要一个代理来将 Redis 连接分发到正确的 Master 上，例如轻量级的 twemproxy。

文件对象存储（File Store）
文件存储负责存储文件对象，并至少在不同的节点上保留一个备份。只要有一个备份可用，就能通过API获得文件。它至少需要支持以下方法：
Post 新增一个文件，并返回 File ID
Delete 根据 File ID 移除一个文件
我们这里采用较为简单的双备份的模式，即接收到文件后，随机选择两个不同的节点，各存储一份。同样的，当发现节点内文件丢失时，立即再复制一份以保证拷贝数等于2。
技术上我们选用了较为轻量级、但性能占优的 SeaweedFS 作为存储后端。

文件系统接口（Filer）
文件系统是本实验的主要模块。我们需要编写代码，实现一个支持以下操作的文件系统：

CreateFile 创建文件
DeleteFile 删除文件
ListFiles 列出某个目录下的文件
CreateDirectory 创建目录
DeleteDirectory 删除目录
ListDirectories 列出某个目录下的目录
此外，需要提供一个简单的用户界面，便于用户使用。

以存储一个文件 /foo/bar.txt 为例，需要经过以下步骤：

检查目录 /foo 是否存在；如果不存在，需要创建目录，并把新目录加入 / 的目录树中。
检查文件 /foo/bar.txt 是否存在；如果存在，则先从 File Store 中删除文件。
上传文件 bar.txt 到 File Store，得到 File ID。
存储条目 /foo/bar.txt 到 Meta Store，并加入到 /foo/ 的目录树中。
对于文件的索引，很自然的，将/path/to/file 映射到 File ID 即可。对于目录树的存储则稍复杂一些。

使用前缀查询是无法满足多级目录树的需求的。我们在 Redis 中创建如下的条目以储存目录结构，来满足 ListFiles 和 ListDirectories 的需求：

目录的目录： /path/to/dir -> {foo_dir:dirId1, bar_dir:dirId2, ...}
文件的目录： /path/to/dir -> {foo_file:fileId1, bar_file:fileId2, ...}
此外，为了方便使用，引用一个开源的网页文件管理器 angular-filemanager 作为用户界面。我们仅需实现对应的后端 API 即可。


完整架构
以下是分布式文件系统项目的整体架构。系统使用 Docker + Kubernetes 来管理各个服务和节点，配合相关工具，很容易在 AWS 或 GCE 上部署。

![](/images/file%20manager.png)

