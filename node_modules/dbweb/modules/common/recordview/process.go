package recordview

import (
	"dbweb/core"
	"dbweb/lib/safe"
	"dbweb/lib/tempext"
	"encoding/json"
	"net/url"
)

//RecordViewProcess 表示一个处理
type RecordViewProcess struct {
	param       *RecordViewParam
	Name        string
	ElementName string
	BindRecord  bool
	//传递到下一个工作元素的路径上，一般用来传递主键，如果为空则自动传递表的主键
	TransPath []string
	//传递到下一个工作元素的参数，用模板来完成,
	//一般是用来传递到另一个RecordView的附加条件及标题
	TransQuery string
	WithSql    bool   //是否传递sql
	Visable    string //非空的话计算可见性，用templater的语法
	MoreStr    string `json:"-" yaml:"-"` //动态传入的more参数，从recordview的query中提取
}

//CanDisplay 判断这个按钮是否能显示
func (r *RecordViewProcess) CanDisplay(v ...interface{}) bool {
	if len(r.Visable) == 0 {
		return true
	}
	var val interface{}
	if len(v) > 0 {
		val = v[0]
	}
	return safe.Bool(tempext.MustExec(r.Visable, val))
}

//URL 获取一个操作的url地址，如果是绑定到记录的，将自动传递TransPath、TransQuery
//否则，传递当前RecordView所有的Query值
func (r *RecordViewProcess) URL(pam ...interface{}) string {
	var row map[string]interface{}

	pks := []string{}
	q := url.Values{}
	if r.BindRecord {
		if len(pam) == 0 {
			core.LOG.Panic("not row")
		}
		row = pam[0].(map[string]interface{})
		pkFields := r.TransPath
		if len(pkFields) == 0 {
			pkFields = r.param.UniqueField
		}
		for _, onePK := range pkFields {
			pks = append(pks, safe.String(row[onePK]))
		}
	} else if r.WithSql {
		q.Add("_rvp", r.param.newID)
	}
	ustr := core.ElementUrl(r.ElementName, pks...)
	//处理TransQuery,将TransQuery中设置的json值转换到Query上去
	if len(r.TransQuery) > 0 {
		queryMap := map[string]interface{}{}
		if err := json.Unmarshal([]byte(r.TransQuery), &queryMap); err != nil {
			core.LOG.Panic(err)
		}
		for k, v := range queryMap {
			switch tv := v.(type) {
			case string:

				q.Set(k, transQueryValue(tv, row, r.param.user))
			default:
				core.LOG.Panic("传递的属性值必须是字符串")
			}
		}
	}
	if len(r.MoreStr) > 0 {
		q.Set("_more", r.MoreStr)
	}
	if len(q) > 0 {
		ustr += "?" + q.Encode()
	}
	return r.param.user.Sign(ustr)
}
