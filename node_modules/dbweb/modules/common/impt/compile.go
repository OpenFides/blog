package impt

import (
	"dbweb/core"
	"dbweb/lib/lsession"
	"text/template"

	"dbweb/lib/tempext"
	"fmt"

	"github.com/linlexing/dbx/schema"
)

//compileRender 编译出一个render
type renderCompiler struct {
	param   *ImportParam
	post    *ImportPostParam
	title   []string
	table   *schema.Table
	user    *core.User
	session *lsession.Session
	more    map[string]interface{}
}

func (r *renderCompiler) findTitle(t string) int {
	for i, v := range r.title {
		if t == v {
			return i
		}
	}
	return -1
}

//compile 编译出一个render
func (r *renderCompiler) compile() (*render, error) {
	renderArgs := map[string]interface{}{
		"User":     r.user,
		"LSession": r.session,
		"More":     r.more,
	}

	cols := map[string]*fieldRender{}
	//先搜索工作元素的参数设置，只有为FILL的才收集
	for _, field := range r.param.Fields {
		if field.Style == "FILL" {
			t, err := template.New("field").Funcs(tempext.FuncMap).Parse(field.Value)
			if err != nil {
				return nil, err
			}
			cols[field.Name] = &fieldRender{
				Column:       r.table.ColumnByName(field.Name),
				fillTemplate: t,
			}
		}
	}
	//再搜索导入时，用户的设置
	for _, field := range r.post.Fields {
		switch field.ColumnName {
		case "(CUSTOM)":
			t, err := template.New("field").Funcs(tempext.FuncMap).Parse(field.Value)
			if err != nil {
				return nil, err
			}
			cols[field.FieldName] = &fieldRender{
				Column:       r.table.ColumnByName(field.FieldName),
				fillTemplate: t,
			}
		case "(SKIP)": //跳过
		default: //其他的视为标题映射
			idx := r.findTitle(field.ColumnName)
			if idx < 0 {
				return nil, fmt.Errorf("not found the title %s at %v", field.ColumnName, r.title)
			}
			cols[field.FieldName] = &fieldRender{
				Column:    r.table.ColumnByName(field.FieldName),
				dataIndex: idx,
			}
		}
	}
	list := []*fieldRender{}
	for _, v := range cols {
		list = append(list, v)
	}

	return &render{
		cols: list,
		args: renderArgs,
	}, nil

}
