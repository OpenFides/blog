package core

import (
	"crypto/hmac"
	"crypto/sha1"
	"encoding/base64"

	"net/url"
)

const secretKey = "llx.nova.2015__1"

//Sign 进行签名,有_s则重新签名
func Sign(strURL, userName string) string {
	/*//考虑到主键内容参与组合url，会有/ ? +等特殊符号，用url.Parse会出问题
	//因此先进行判断，是否有?，即是否有query参数，如果没有，则url不进行进一步解析
	//以免破坏已经编码的特殊符号
	if strings.Index(strUrl, "?") < 0 {
		mac := hmac.New(sha1.New, []byte(secretKey))
		mac.Write([]byte(strUrl))
		mac.Write([]byte(userName))
		bys := mac.Sum(nil)
		val := url.Values{}
		val.Set("_s", base64.RawURLEncoding.EncodeToString(bys))

		return strUrl + "?" + val.Encode()
	}*/
	u, err := url.Parse(strURL)
	if err != nil {
		LOG.Panic(err)
	}
	mac := hmac.New(sha1.New, []byte(secretKey))
	mac.Write([]byte(u.Path))
	mac.Write([]byte(userName))
	bys := mac.Sum(nil)
	val := u.Query()
	val.Set("_s", base64.RawURLEncoding.EncodeToString(bys))
	u.RawQuery = val.Encode()
	return u.String()
}

//IsSign url是否通过验证
func IsSign(u *url.URL, userName string) bool {
	if u.Query().Get("_s") == "" {
		LOG.Println(u.String(), "not _s query param")
		return false
	}
	sByte, err := base64.RawURLEncoding.DecodeString(u.Query().Get("_s"))
	if err != nil {
		LOG.Panic(err)
	}

	mac := hmac.New(sha1.New, []byte(secretKey))
	mac.Write([]byte(u.Path))
	mac.Write([]byte(userName))
	bys := mac.Sum(nil)
	return hmac.Equal(bys, sByte)
}
